import requests
import re
def has_default_credentials(url):
    """
    Attempts login with common default credentials, indicating a misconfiguration if login succeeds.
    """
    default_creds = [
        ("admin", "admin"),
        ("root", "root"),
        ("user", "password"),
        ("admin", "password")
    ]
    login_url = f"{url}/login"  # Adjust endpoint as needed
    for username, password in default_creds:
        response = requests.get(login_url, data={"username": username, "password": password})
        if response.status_code == 200 and "Welcome" in response.text:
            return True  # Default credentials allowed
    return False

def has_inadequate_rbac(url, restricted_endpoint="/user/settings"):
    """
    Checks if role-based access control (RBAC) is not properly implemented by attempting to access restricted user pages.
    """
    test_url = url + restricted_endpoint
    try:
        response = requests.get(test_url, timeout=5)
        # Check if unauthorized users can access role-protected pages
        if response.status_code == 200 and "settings" in response.text.lower():
            return True
    except requests.RequestException:
        return False
    return False

def has_insecure_framework_configuration(url):
    """
    Checks if the application is using default, potentially insecure settings in common frameworks (e.g., Django DEBUG mode).
    """
    try:
        response = requests.get(url, timeout=5)
        if "settings.DEBUG = True" in response.text or "Django" in response.headers.get("Server", ""):
            return True
    except requests.RequestException:
        return False
    return False

def is_mime_type_spoofing_possible(url, file_path, spoofed_content_type="image/png"):
    """
    Tests for MIME type spoofing by uploading a non-image file with an image MIME type.
    """
    try:
        with open(file_path, 'rb') as f:
            files = {'file': (file_path, f, spoofed_content_type)}
            response = requests.post(f"{url}/upload", files=files)
        
        # If the server accepts the file, MIME type spoofing may be possible
        if response.status_code == 200 and "file uploaded" in response.text.lower():
            return True
    except FileNotFoundError:
        print(f"File {file_path} not found.")
    except requests.RequestException as e:
        print(f"Error during MIME type spoofing check: {e}")
    
    return False

def is_open_redirect_vulnerable(url):
    """
    Checks if the application is vulnerable to open redirects by manipulating a common redirect parameter.
    """
    test_redirect_url = f"{url}?redirect=http://evil.com"
    try:
        response = requests.get(test_redirect_url, allow_redirects=False, timeout=5)
        if response.status_code in [301, 302] and "evil.com" in response.headers.get("Location", ""):
            return True
    except requests.RequestException:
        return False
    return False

def is_file_upload_unrestricted(url, file_path):
    """
    Tests for unrestricted file uploads by attempting to upload a malicious file.
    """
    try:
        with open(file_path, 'rb') as f:
            files = {'file': f}
            response = requests.post(f"{url}/upload", files=files)
        
        # Check if the file is uploaded successfully
        if response.status_code == 200 and "file uploaded" in response.text.lower():
            return True  # Indicates unrestricted file upload vulnerability
    except FileNotFoundError:
        print(f"File {file_path} not found.")
    except requests.RequestException as e:
        print(f"Error during file upload: {e}")
    
    return False

def uses_weak_crypto(url):
    """
    Scans for weak cryptographic algorithms by looking for insecure ciphers in the code.
    """
    response = requests.get(url)
    weak_crypto_patterns = [
        re.compile(r"AES-\d{3}-ECB"),  # ECB mode is weak
        re.compile(r"MD5\(|SHA1\(")  # MD5 and SHA1 are outdated
    ]
    
    for pattern in weak_crypto_patterns:
        if pattern.search(response.text):
            return True  # Weak cryptographic algorithm found
    return False

def is_cors_configuration_insecure(url):
    """
    Checks for insecure CORS configuration by examining the headers in the response.
    """
    try:
        response = requests.get(url)
        cors_headers = response.headers.get("Access-Control-Allow-Origin", "")
        allow_credentials = response.headers.get("Access-Control-Allow-Credentials", "")
        
        # Check for insecure CORS configurations
        if cors_headers == "*" or "null" in cors_headers or (cors_headers and allow_credentials == "true"):
            return True  # Indicates an insecure CORS configuration
    except requests.RequestException as e:
        print(f"Error during CORS check: {e}")
    
    return False