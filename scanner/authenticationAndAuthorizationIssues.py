import jwt
import requests
import re

def has_weak_authorization(url, sensitive_endpoint="/admin"):
    """
    Checks if sensitive endpoints (e.g., admin pages) are accessible without proper authorization.
    """
    test_url = url + sensitive_endpoint
    try:
        response = requests.get(test_url, timeout=5)
        # Check if unauthorized users have access to restricted pages
        if response.status_code == 200 and "admin" in response.text.lower():
            return True
    except requests.RequestException:
        return False
    return False

def is_session_hijacking_vulnerable(url):
    response = requests.get(url)
    cookies = response.cookies

    # Check if 'secure' and 'HttpOnly' flags are set for session cookies
    vulnerable = False
    for cookie in cookies:
        if "session" in cookie.name.lower() and not cookie.get("secure"):
            print(f"Session cookie '{cookie.name}' is not secure.")
            vulnerable = True
        if "session" in cookie.name.lower() and not cookie.get("HttpOnly"):
            print(f"Session cookie '{cookie.name}' is not HttpOnly.")
            vulnerable = True
            
    # Simulate session hijacking attempt by using a valid session ID (in a real-world attack, this would be stolen)
    session_cookie = cookies.get('session')
    if session_cookie:
        response = requests.get(url, cookies={"session": session_cookie})
        if response.status_code == 200:
            print(f"Session hijacking successful with cookie '{session_cookie}'")
            vulnerable = True

    return vulnerable

def is_idor_vulnerable(url, test_user_id=1, unauthorized_user_id=2):
    """
    Checks for IDOR by attempting to access another user's resources without proper authorization.
    """
    test_url = f"{url}/user/{test_user_id}"
    unauthorized_url = f"{url}/user/{unauthorized_user_id}"
    
    # Simulate an authorized request
    auth_response = requests.get(test_url, headers={"Authorization": "Bearer valid_token"})
    
    # Simulate an unauthorized request
    unauth_response = requests.get(unauthorized_url, headers={"Authorization": "Bearer valid_token"})
    
    if auth_response.status_code == 200 and unauth_response.status_code == 200 and auth_response.text != unauth_response.text:
        return True  # Indicates potential IDOR vulnerability
    return False

def is_csrf_vulnerable(url, csrf_protected_action="/profile/update"):
    """
    Tests for CSRF vulnerability by performing an action that requires CSRF protection and observing the response.
    Flags if no CSRF token is required.
    """
    # CSRF-protected action endpoint
    action_url = f"{url}{csrf_protected_action}"
    response = requests.get(action_url, data={"key": "value"}, headers={"Referer": url})
    
    # Check for lack of CSRF protection message or error response
    if response.status_code == 200 and "CSRF" not in response.text:
        return True  # No CSRF protection detected
    return False

def is_api_authentication_broken(url, api_key=None):
    headers = {}
    if api_key:
        headers['Authorization'] = f"Bearer {api_key}"
    
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        return True  # No authentication required, indicating a broken API authentication
    return False

def is_jwt_insecure(url):
    """
    Verifies JWT token security by checking for the presence of an expiration field and verifying token's secure handling.
    """
    response = requests.get(url)
    jwt_token = response.headers.get('Authorization')
    
    if jwt_token:
        try:
            decoded_token = jwt.decode(jwt_token, options={"verify_signature": False})
            if 'exp' not in decoded_token:
                return True  # JWT has no expiration
            # Further checks for secure handling can include verifying claims and algorithms
        except jwt.DecodeError:
            return False  # Token is invalid, but not necessarily insecure
    return False